TODO:

* Use autofac to setup the Collections library
* use Roslyn as a compiler 
* add links to msdn doc. user must be able to easily go to official doc when mouse over stuff.... or similar
* micromanage the threading/task handling to get more smooth and instant feedback. dont burden the ui thread.
* IMPORTANT: most often code will not be simple, i.e. it will be complex, contain references to other assemblies, etc.
user should be able to select an assembly to work with, when selected, all types are listed in listObjects. dont show code.
* must not be able to compile other than "from folder", or own code
* investigate best practices for async await


Explore
* load assemblies, code files
* see and modify code (when code files are loaded)
* run methods (when params are present and they are supported random arg values are generated for each run)
* instantiate classes
* a param may be supported if that type is provided and can be easily get a random value. for example void Add(MyType x) may work 
with reflection. Reflection the item can be instantiated, but if it is a complex object then it will be hard to generate a random such...
* user can see how long it takes to run something, min, max, avg values, successrate, log of what went wrong, log of random runs.
* pre jit stuff for more correct results
* can own code output to Console? would be nice
continue with this : http://msdn.microsoft.com/en-us/magazine/dd419663.aspx



* contextmenu -> show in code explorer (will show the code in the explorer)
* when code has changed, highlight that in some way
* feels awkward to have info as a flyout.. maybe make more like the log window.
* add a "shake" effect on runners, when they have high fail rate.
* present a log over 10 randomly collected successed executions, and 10 failed ones. Maybe make that as a setting value
* make splitter to use accent color
* format the contents of the runners and info flyout (pplacement, etc)
* having that optimization for methods withaout params and return values might be misleading for users.



---------------- TODO ---------------------
* continue with the new stuff.
* now its quick and dirty.
* the dataflow is out of sync




---- architecture ----

* divide into modules. what modules are there?
- gui
	- canvas, shapes, animations
	- explore mode
	- play mode
	- other (roslyn ) mode
	- 
- runners, method execution, updates, dataflow stuff, (the engine)
- type loader, reflection, all that (content/resources)
- logging
- runtime that binds all modules (the main)
- messaging, own module or part of engine?
- bootstrapper


--- the engine ---
* deps:
	- compiler (native or roslyn), as an ICompilerService maybe
	- objectbehavior/objectcontainer (how to run stuff)
	- irunner (tpl or bw)
	- typeloader
	- runner settings

	-- 



--- REFACTOOOORRRR ---
* split types loader into 2: what it does and the compiler


* typesviewmodel and exploremodeviewmodel, make them awesome databinded piece of works!!!